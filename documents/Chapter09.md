- 일반적인 빅데이터 플랫폼에서...
  - 단기간 처리는 스트리밍 플랫폼으로 하고
  - 장기 데이터는 별도의 장기 저장소와 별도의 배치 처리 시스템을 사용

- KSQL 을 사용하여 저장 기간에 관계 없이 스트리밍과 배치 처리 동시 가능

9.1 KSQL 등장 배경

- 보통, 카프카를 데이터 버스로 사용하고, 데이터 가공해서 다른 곳에 저장
    - 카멜, 스톰, 스파크 스트리밍, 삼자 등을 활용
    - 카프카는 특정 큐로 데이터 들어왔을 때 정해진 툴을 적용하는 "큐 라우팅" 기능이 약함

- 카카오 케미 (KEMI STATS)
    - !(카카오 케미)[]
    - KEMI : 알림 STATS, 로그 LOG
    - KEMI STATS : POLLING 방식, PUSH 방식
    - KEMI STATS POLLING (1분 주기)
        - 람다 아키텍처 적용
        - Job Controller : 모니터링 장비 목록 정의
        - etcd : 모니터링 항목 정의
        - Poller :
            - Producee의 장비 목록을 보고 있다가 etcd 항목을 실제 서버에서 수집
            - 연산이 필요한 것 (DISK usage 등)은 삼자를 통해 가공해서 카프카에 등록

    - 람다 아키텍처
        - ![카프카 람다 아키텍처]()
        - 데이터를  처리해서 기간과 용량에 따라 별도의 저장소를 가져가는 방식
        - 장점
            - 적절한 기술을 조합해서 쉽게 구축 가능
            - 병목시 특정 컴포넌트만 증가하여 확장 가능
        - 단점
            - 너무 많은 기술 사용
            - 단기, 장기 데이터를 별도 관리해야 해서 관리 비용 부담
            - 결국 작은 규모에서는 관리하기 어려움
         => 간단한 계산, 필터링은 카프카에서 수행, 장/단기 구분 없이 동일한 사용 원함 : 카파 아키텍처 등장


9.2 KSQL과 카파 아키텍처

-카파 아키텍처
    - ![카프카 카파 아키텍처]()
    - 크기나 기간에 관계없이 하나의 계산 프로그램 사용
    - 장기 데이터 따로 저장하지 않고 장기 데이터 조회가 필요한 경우 그때그때 계한하여 전달
    - 람다 아키텍처와의 비교
        - 데이터 제공 영역이 없어짐 => 언제나 계산을 통해 만들어 내는 것이 핵심
    - 저장 기간별 데이터 처리 방식
        - 단기 데이터 : 토픽에 저장하고, 스파크나 스톰 또는 삼자를 통해 결과를 만들어냄
        - 장기 데이터 : 하둡에 복사하고, 맵리듀스나 스파크를 통해 결과를 만들어냄
    - 저장 기간에 관계없이 통합하게 하면? => KSQL
    

KSQL 아키텍처

    ![KSQL architecture]()

- 구성
    - KSQL 서버
        - REST API 서버 : 사용자 쿼리 받기
        - 쿼리 실행 엔진 : 논리적/물리적 실행 계획 생성 및 실행. 카프카 토픽 읽거나 생성
    - KSQL 클라이언트
        - 사용자가 SQL 쿼리문 작성하도록 인터페이스 제공
        - KSQL에 연결

- KSQL 서버
    - 쿼리 실행 절차
        -